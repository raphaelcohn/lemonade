#!/usr/bin/env sh
# This file is part of lemonade. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/lemonade/master/COPYRIGHT. No part of rust1, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2016 The developers of lemonade. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/lemonade/master/COPYRIGHT.


set -e
set -u
set -f

_program_path_find()
{
    if [ "${_program_fattening_program_path+set}" = 'set' ]; then
        printf '%s\n' "$_program_fattening_program_path"

    elif [ "${0%/*}" = "$0" ]; then

        # We've been invoked by the interpreter as, say, bash program
        if [ -r "$0" ]; then
            pwd -P
        # Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
        else
            printf '\n'
        fi

    else

        # We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

        _program_path_find_parentPath()
        {
            parentPath="${scriptPath%/*}"
            if [ -z "$parentPath" ]; then
                parentPath='/'
            fi
            cd "$parentPath" 1>/dev/null
        }

        # pdksh / mksh have problems with unsetting a variable that was never set...
        if [ "${CDPATH+set}" = 'set' ]; then
            unset CDPATH
        fi

        if command -v realpath 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$(realpath "$0")"

                _program_path_find_parentPath
                pwd -P
            )
        elif command -v readlink 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$0"

                while [ -L "$scriptPath" ]
                do
                    _program_path_find_parentPath
                    scriptPath="$(readlink "$scriptPath")"
                done

                _program_path_find_parentPath
                pwd -P
            )
        else
            # This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
            (
                scriptPath="$0"

                _program_path_find_parentPath
                pwd -P
            )
        fi

    fi
}

download_caddy_fail()
{
	local message="$1"
	
	printf 'download-caddy:FAIL:%s\n' "$message"
	exit 1
}

download_caddy_bug()
{
	local message="$1"
	
	printf 'download-caddy:BUG:%s\n' "$message"
	exit 2
}

download_caddy_assertProgramIsPresent()
{
	local unameOs="$1"
	local commandToFind="$2"
	
	local checkForProgramPresence
	if [ "$unameOs" = 'ANY' ]; then
		checkForProgramPresence=true
	elif [ "$unameOs" = "$(uname)" ]; then
		checkForProgramPresence=true
	else
		checkForProgramPresence=false
	fi
	
	if $checkForProgramPresence; then
		if ! command -v "$commandToFind" 1>/dev/null 2>/dev/null; then
			download_caddy_fail "Essential command '$commandToFind' is not on the PATH"
		fi
	fi
}
download_caddy_assertProgramIsPresent ANY uname

download_caddy_folderIsExtantReadableAndSearchable()
{
	local folderPathName="$1"
	local folderPath="$2"

	if [ ! -d "$folderPath" ]; then
		download_caddy_fail "$folderPathName folder path '$folderPath' does not exist as a folder"
	fi
	if [ ! -r "$folderPath" ]; then
		download_caddy_fail "$folderPathName folder path '$folderPath' is not readable"
	fi
	if [ ! -x "$folderPath" ]; then
		download_caddy_fail "$folderPathName folder path '$folderPath' is not searable"
	fi
}

download_caddy_folderIsExtantReadableAndSearchableAndWritable()
{
	local folderPathName="$1"
	local folderPath="$2"

	download_caddy_folderIsExtantReadableAndSearchable "$folderPathName" "$folderPath"
	
	if [ ! -w "$folderPath" ]; then
		download_caddy_fail "$folderPathName folder path '$folderPath' is not writable"
	fi
}

download_caddy_fileIsExtantReadableAndNotEmpty()
{
	local filePathName="$1"
	local filePath="$2"

	if [ ! -f "$filePath" ]; then
		download_caddy_fail "$filePathName file path '$filePath' does not exist as a file"
	fi
	if [ ! -r "$filePath" ]; then
		download_caddy_fail "$filePathName file path '$filePath' is not readable"
	fi
	if [ ! -s "$filePath" ]; then
		download_caddy_fail "$filePathName file path '$filePath' is empty"
	fi
}

download_caddy_setConfigurationFolderPath()
{
	configurationFolderPath="$programPath"
	download_caddy_folderIsExtantReadableAndSearchable 'configuration' "$configurationFolderPath"
}

download_caddy_setTemporaryFolderPath()
{
	temporaryFolderPath="$programPath"/temporary
}

download_caddy_assertProgramIsPresent ANY mkdir
download_caddy_setCacheFolderPath()
{
	cacheFolderPath="$configurationFolderPath"/cache
	mkdir -m 0700 -p "$cacheFolderPath"
	download_caddy_folderIsExtantReadableAndSearchableAndWritable 'cache' "$cacheFolderPath"
}

download_caddy_assertProgramIsPresent ANY uname
download_caddy_findOperatingSystemAndMachine()
{
	if [ $# -eq 2 ]; then
		local unameOperatingSystem="$1"
		local unameMachine="$2"
	else
		local unameOperatingSystem="$(uname)"
		local unameMachine="$(uname -m)"
	fi

	export CASE_SENSITIVE_PATH=true
	caddy_arm=''
	caddy_dl_ext='tar.gz'
	caddy_bin='caddy'
	case "$unameOperatingSystem" in
		
	 	Linux)
			caddy_os='linux'
	
			case "$unameMachine" in
		
				*aarch64*)
					caddy_arch="arm64"
				;;
		
				*64*)
					caddy_arch="amd64"
				;;
		
				*86*)
					caddy_arch="386"
				;;
		
				*armv5*)
					caddy_arch="arm"
					caddy_arm='5'
				;;
		
				*armv6l*)
					caddy_arch="arm"
					caddy_arm='6'
				;;
		
				*armv7l*)
					caddy_arch="arm"
					caddy_arm='7'
				;;
		
				*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m (NOTE: PowerPC and MIPS downloads are not supported by this script)"
				;;
		
			esac
		;;
		
		Darwin)
			caddy_dl_ext='zip'
			caddy_os='darwin'
			caddy_arch="amd64"
			
			if [ "$unameMachine" != 'x86_64' ]; then
				download_caddy_fail "Only Amd64 is supported for Mac OS X"
			fi
		;;
		
		DragonFly)
			caddy_os='dragonfly'
			caddy_arch="amd64"
			
			if [ "$unameMachine" != 'x86_64' ]; then
				download_caddy_fail "Only Amd64 is supported for DragonFly"
			fi
		;;
		
		FreeBSD)
			caddy_os='freebsd'
	
			case "$unameMachine" in
		
				*aarch64*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
				
				*64*)
					caddy_arch="amd64"
				;;
		
				*86*)
					caddy_arch="386"
				;;
		
				*armv6l*)
					caddy_arch="arm"
					caddy_arm='6'
				;;
		
				*armv7l*)
					caddy_arch="arm"
					caddy_arm='7'
				;;
		
				*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
		
			esac
		;;
		
		OpenBSD)
			caddy_os='openbsd'
	
			case "$unameMachine" in
		
				*aarch64*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
				
				*64*)
					caddy_arch="amd64"
				;;
		
				*86*)
					caddy_arch="386"
				;;
		
				*armv6l*)
					caddy_arch="arm"
					caddy_arm='6'
				;;
		
				*armv7l*)
					caddy_arch="arm"
					caddy_arm='7'
				;;
		
				*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
		
			esac
		;;
		
		NetBSD)
			caddy_os='netbsd'
	
			case "$unameMachine" in
		
				*aarch64*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
				
				*64*)
					caddy_arch="amd64"
				;;
		
				*86*)
					caddy_arch="386"
				;;
		
				*armv6l*)
					caddy_arch="arm"
					caddy_arm='6'
				;;
		
				*armv7l*)
					caddy_arch="arm"
					caddy_arm='7'
				;;
		
				*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
		
			esac
		;;
		
		SunOS)
			caddy_os='solaris'
	
			case "$unameMachine" in
		
				*aarch64*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
				
				*64*)
					caddy_arch="amd64"
				;;
		
				*)
					download_caddy_fail "Unsupported machine architecture '$unameMachine' from uname -m"
				;;
		
			esac
		;;
		
		MINGW_*|MSYS_*|*WIN*)
			caddy_dl_ext='zip'
			caddy_os='windows'
			caddy_bin='caddy.exe'
			export CASE_SENSITIVE_PATH=false
			
			download_caddy_fail "Windows is not supported by this script"
		;;
		
		*)
			download_caddy_fail "Unsupported operating system '$unameOperatingSystem' from uname"
		;;
		
	esac
}

download_caddy_assertProgramIsPresent ANY sort
download_caddy_assertProgramIsPresent ANY rm
download_caddy_findPlugins()
{
	local pluginsFilePath="$configurationFolderPath"/caddy.plugins
	download_caddy_fileIsExtantReadableAndNotEmpty 'caddy plugins list' "$pluginsFilePath"
	
	local sortedPluginsFilePath="$temporaryFolderPath"/caddy.plugins.sorted
	sort -u "$pluginsFilePath" >"$sortedPluginsFilePath"
	
	caddy_plugins=''
	local pluginName
	while IFS='' read -r pluginName
	do
		case "$pluginName" in
			
			'')
				continue
			;;
			
			'#'*)
				continue
			;;
			
		esac
		
		if [ -z "$caddy_plugins" ]; then
			caddy_plugins="$pluginName"
		else
			caddy_plugins="$caddy_plugins","$pluginName"
		fi
	done <"$sortedPluginsFilePath"
	
	rm -rf "$sortedPluginsFilePath"
}

download_caddy_assertProgramIsPresent ANY rm
download_caddy_assertProgramIsPresent ANY mkdir
download_caddy_assertProgramIsPresent ANY wget
download_caddy_assertProgramIsPresent ANY chmod
download_caddy_assertProgramIsPresent ANY mv
download_caddy_assertProgramIsPresent Darwin unzip
download_caddy_assertProgramIsPresent Linux tar
download_caddy_assertProgramIsPresent ANY id
download_caddy_ensureCaddyIsDownloadedAndCached()
{
	rm -rf "$temporaryFolderPath"
	mkdir -m 0700 -p "$temporaryFolderPath"
	
	local caddy_os
	local caddy_arch
	local caddy_arm
	local caddy_dl_ext
	local caddy_bin
	download_caddy_findOperatingSystemAndMachine "$@"
		
	local caddy_plugins
	download_caddy_findPlugins
	
	caddyServerFilePath="$cacheFolderPath"/caddy."${caddy_os}"."${caddy_arch}${caddy_arm}"."${caddy_plugins}"
	
	if [ ! -x "$caddyServerFilePath" ]; then
		local caddyArchiveFilePath="$temporaryFolderPath"/caddy."${caddy_dl_ext}"
		rm -rf "$caddyArchiveFilePath"
	
		local caddyExtractFolderPath="$temporaryFolderPath"/extracted-download
		rm -rf "$caddyExtractFolderPath"
		mkdir -m 0700 -p "$caddyExtractFolderPath"
		
		rm -rf "$caddyServerFilePath"
		set +e
			wget -O "$caddyArchiveFilePath" "https://caddyserver.com/download/${caddy_os}/${caddy_arch}${caddy_arm}?plugins=${caddy_plugins}" 1>/dev/null 2>/dev/null
			local exitCode=$?
		set -e
		
		if [ $exitCode -ne 0 ]; then
			rm -rf "$caddyArchiveFilePath"
			download_caddy_fail "wget of caddy failed with code '$exitCode'"
		fi
		
		case "$caddy_dl_ext" in
			
			zip)
				unzip -o "$caddyArchiveFilePath" "$caddy_bin" -d "$caddyExtractFolderPath" 1>/dev/null 2>/dev/null
			;;
			
			tar.gz)
				tar -xf "$caddyArchiveFilePath" -C "$caddyExtractFolderPath" "$caddy_bin" 1>/dev/null 2>/dev/null
			;;
			
			*)
				download_caddy_bug "Unexpected 'caddy_dl_ext' '$caddy_dl_ext'"
			;;
			
		esac
		
		rm -rf "$caddyArchiveFilePath"
		
		chmod 0700 "$caddyExtractFolderPath"/"$caddy_bin"
		mv "$caddyExtractFolderPath"/"$caddy_bin" "$caddyServerFilePath"
		rm -rf "$caddyExtractFolderPath"
		
		local currentUserId="$(id -u)"
		
		if [ "$currentUserId" -ne 0 ]; then
			# Need to do this for Linux to run on ports < 1024
			# setcap cap_net_bind_service=+ep "$caddyServerFilePath"
			:
		fi
	fi
	
	rm -rf "$temporaryFolderPath"
}

download_caddy_set()
{
	local variableName="$1"
	local value="$2"
	
	local namespacedName=DOWNLOAD_CADDY_"$variableName"
	
	eval "$namespacedName"'=$value'
}

download_caddy_defaults()
{
	download_caddy_set ULIMIT 8192
	
	download_caddy_set ACME_AGREE true
	download_caddy_set LOG_STANDARD_ERROR false
	# -logtostderr

	# Typically needed for dev, staging, etc - an environment setting
	download_caddy_set ACME_CA 'https://acme-v01.api.letsencrypt.org/directory'
	
	download_caddy_set ACME_CA_TIMEOUT '10s'
	#-conf
	download_caddy_set CPU '100%'  # Can also be a number of cores, eg 3
	download_caddy_set ACME_DISABLE_HTTP_CHALLENGE false
	download_caddy_set ACME_DISABLE_TLS_SNI_CHALLENGE false
	download_caddy_set DNS_PORT 53
	download_caddy_set ACME_EMAIL 'webmaster@stormmq.com'
	download_caddy_set GRACEFUL_SHUTDOWN_DURATION '5s'
	download_caddy_set DEFAULT_HOST 'localhost'
	download_caddy_set HTTP_PORT 80
	# -http2
	download_caddy_set HTTPS_PORT 443
	# -log
	# -log_backtrace_at
	# -log_dir
	# -pidfile
	download_caddy_set DEFAULT_PORT 2015
	download_caddy_set ENABLE_QUIC_PROTOCOL false
	# -root
	
	download_caddy_set SERVER_TYPE 'http'
}

_download_caddy_loadConfiguration()
{
	local fileBaseName="$1"
	
	local caddyConfigurationFilePath="$configurationFolderPath"/"$fileBaseName"
	if [ ! -s "$caddyConfigurationFilePath" ]; then
		return 0
	fi
	
	set +e
		. "$caddyConfigurationFilePath"
		local exitCode=$?
	set -e
	if [ $exitCode -ne 0 ]; then
		download_caddy_fail "Could not source configuration file '$caddyConfigurationFilePath'"
	fi
}

download_caddy_loadConfiguration()
{
	export DOWNLOAD_CADDY_ENVIRONMENT="$caddy_environment"
	
	_download_caddy_loadConfiguration caddy.configuration.sh
	_download_caddy_loadConfiguration environments/"$caddy_environment"/public.caddy.configuration.sh
	_download_caddy_loadConfiguration environments/"$caddy_environment"/secret.caddy.configuration.sh
}

download_caddy_execute()
{	
	ulimit -n "$DOWNLOAD_CADDY_ULIMIT"
	
	set -- -quiet "$@"
	
	if $DOWNLOAD_CADDY_ACME_AGREE; then
		set -- "$@" -agree
	fi
	
	if $DOWNLOAD_CADDY_LOG_STANDARD_ERROR; then
		set -- "$@" -alsologtostderr
	fi

	set -- "$@" -ca "$DOWNLOAD_CADDY_ACME_CA"
	
	set -- "$@" -catimeout "$DOWNLOAD_CADDY_ACME_CA_TIMEOUT"
	
	#set -- "$@" -conf 'Caddyfile'
	
	set -- "$@" -cpu "$DOWNLOAD_CADDY_CPU"
	
	if $DOWNLOAD_CADDY_ACME_DISABLE_HTTP_CHALLENGE; then
		set -- "$@" -disable-http-challenge
	fi
	
	if $DOWNLOAD_CADDY_ACME_DISABLE_TLS_SNI_CHALLENGE; then
		set -- "$@" -disable-tls-sni-challenge
	fi

	set -- "$@" -dns.port "$DOWNLOAD_CADDY_DNS_PORT"

	set -- "$@" -email "$DOWNLOAD_CADDY_ACME_EMAIL"
	
	set -- "$@" -grace "$DOWNLOAD_CADDY_GRACEFUL_SHUTDOWN_DURATION"
	
	set -- "$@" -host "$DOWNLOAD_CADDY_DEFAULT_HOST"

	set -- "$@" -http-port "$DOWNLOAD_CADDY_HTTP_PORT"

	set -- "$@" -https-port "$DOWNLOAD_CADDY_HTTPS_PORT"
	
	# -log

	# -log_backtrace_at
	
	# -log_dir

	# -logtostderr
	
	# -pidfile
	
	set -- "$@" -port "$DOWNLOAD_CADDY_DEFAULT_PORT"
	
	if $DOWNLOAD_CADDY_ENABLE_HTTP2_PROTOCOL; then
		set -- "$@" -http2
	fi
	
	if $DOWNLOAD_CADDY_ENABLE_QUIC_PROTOCOL; then
		set -- "$@" -quic
	fi
	
	set -- "$@" -root ./root
	
	# -stderrthreshold VALUE
	
	set -- "$@" -type "$DOWNLOAD_CADDY_SERVER_TYPE"
	
	# -v value (log level)
	
	# -vmodule ????
	
	cd "$configurationFolderPath" 1>/dev/null 2>/dev/null
	exec "$caddyServerFilePath" "$@"
}

download_caddy_showHelp()
{
	cat <<-EOF
		download-caddy
		  runs as if called as `download-caddy serve production`
		download-caddy MODE ...
		  where MODE can be one of:-
		    download  Ensures caddy is downloaded (for this machine and a specific one)
		    serve     Serve web pages
		    revoke    Revoke a HTTPS certificate
		    validate  Validate Caddyfile
		    version   Show version and exit
		    plugins   Show list of installed plugins and exit
		    help      Show this help and exit
		
		The following modes take additional arguments:-
		  download OS ARCH
		    OS           Operating system as would be from `uname`
		    ARCH         Architecture as would be from `uname -m`
		  serve [ENVIRONMENT]
		    ENVIRONMENT  Custom environment overrides to use
                         Defaults to `production`
		  revoke HOST [ENVIRONMENT]
		    HOST         Host to revoke certificate for
		    ENVIRONMENT  Custom environment overrides to use
                         Defaults to `production`
		  validate [ENVIRONMENT]
		    ENVIRONMENT  Custom environment overrides to use
                         Defaults to `production`
	EOF
}

_download_caddy_mode_parseEnvironment()
{
	case "$#" in
		
		'0')
			caddy_environment='production'
		;;
		
		'1')
			caddy_environment="$1"
		;;
		
		*)
			download_caddy_mode_fail
		;;
		
	esac
}

download_caddy_mode_download()
{
	download_caddy_prepare
	
	download_caddy_ensureCaddyIsDownloadedAndCached "$@"
}

download_caddy_mode_serve()
{
	local caddy_environment
	_download_caddy_mode_parseEnvironment "$@"
	
	download_caddy_prepareForExecution "$@"
	download_caddy_execute
}

download_caddy_mode_revoke()
{
	if [ $# -eq 0 ]; then
		download_caddy_fail "Please supply HOST"
	fi
	local hostToRevoke="$1"
	shift 1
	
	local caddy_environment
	_download_caddy_mode_parseEnvironment "$@"
	
	download_caddy_prepareForExecution "$@"
	download_caddy_execute -revoke
}

download_caddy_mode_validate()
{
	local caddy_environment
	_download_caddy_mode_parseEnvironment "$@"
	
	download_caddy_prepareForExecution "$@"
	download_caddy_execute -validate
}

download_caddy_mode_version()
{
	if [ $# -ne 0 ]; then
		download_caddy_mode_fail
	fi
	download_caddy_prepare
	
	exec "$caddyServerFilePath" -version
}

download_caddy_mode_plugins()
{
	if [ $# -ne 0 ]; then
		download_caddy_mode_fail
	fi
	download_caddy_prepare
	
	exec "$caddyServerFilePath" -plugins
}

download_caddy_mode_help()
{
	if [ $# -ne 0 ]; then
		download_caddy_mode_fail
	fi
	
	download_caddy_showHelp
	exit 0
}

download_caddy_mode_fail()
{
	printf 'download-caddy:FAIL:%s\n\n' 'Unrecognised command line'
	download_caddy_showHelp 1>&2
	exit 1
}

download_caddy_parseCommandLine()
{
	if [ $# -eq 0 ]; then
		caddy_mode='serve'
	else
		
		case "$1" in
			
			-h|-help|--help)
				caddy_mode='help'
			;;
			
			download|serve|revoke|validate|version|plugins|help)
				caddy_mode="$1"
			;;
			
			*)
				caddy_mode='fail'
			;;
			
		esac
	fi
}

download_caddy_prepare()
{
	download_caddy_setConfigurationFolderPath
	
	download_caddy_setTemporaryFolderPath
	
	download_caddy_setCacheFolderPath
	
	download_caddy_ensureCaddyIsDownloadedAndCached
}

download_caddy_assertProgramIsPresent ANY mkdir
download_caddy_prepareForExecution()
{	
	download_caddy_prepare
	
	download_caddy_defaults
	
	export CADDYPATH="$cacheFolderPath"/"$caddy_environment"
	mkdir -m 0700 -p "$CADDYPATH"
	
	download_caddy_loadConfiguration
}

download_caddy_main()
{
	local programPath="$(_program_path_find)"
	cd "$programPath"/.. 1>/dev/null 2>/dev/null
		local homeFolder="$(pwd)"
	cd - 1>/dev/null 2>/dev/null
	
	local caddy_mode
	download_caddy_parseCommandLine "$@"
	if [ $# -ne 0 ]; then
		shift 1
	fi
	download_caddy_mode_${caddy_mode} "$@"
}

download_caddy_main "$@"
